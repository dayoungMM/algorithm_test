# 구현
- 구현: 머리속에 있는 알고리즘을 정확하고 빠르게 프로그램으로 작성하는 과정
- 대표 유형
  - 완전탐색: 모든 경우의 수를 빠짐없이 다 계산. 모든 경우의 수가 적은 경우 사용
  - 시뮬레이션: 문제에서 제시하는 논리나 동작 과정을 그대로 코드로 옮겨야 하는 유 
## 상하좌우 (UpDownLeftRight)
> 여행가가 N*N 크기의 정사각형 공간 위에 서있다. 가장 왼쪽 위 좌표는 (1,1), 가장 오른쪽 아래 좌표는 (N,N이다). 여행가는 이동계획서에 따라 이동하는데, 이동계획서의 아래 문자의 List로 되어있다. 단, N*N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다.
> 이동 후 좌표를 구하시오
- L: 왼쪽으로 한칸 이동
- R: 오른쪽으로 한칸 이동
- U: 위로 한칸 이동
- D: 아래로 한칸 이동

## 시각 (Time)
> 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 시각중에 3이 하나라도 포함되는 모든 경우의 수 구하시오

## 왕실의 나이트 (Knight)
> 체스판 (8*8)에 나이트가 서있다. 나이트는 L자 형태로만 이동할 수 있으며, 정원 밖으로 나갈 수 없다. 나이트는 2가지 경우로 이동할 수 있다.
- 수평으로 두칸 이동한 뒤 수직으로 한칸이동
- 수직으로 두칸 이동한 뒤 수평으로 한칸 이동

## 게임 개발(Game)
> 캐릭터는 N*M 크기의 직사각형에 있다. 맵의 각 칸은 (A,B)로 나타낼 수 있고 각각 (row, column) 이다. 캐릭터는 상하좌우로 움직이며 바다로 되어있는 공간에는 갈 수 ㅇ벗다
- 현재위치에서 왼쪽방향부터 차례대로 갈 곳을 정함
- 왼쪽에 가보지 않은 칸이 있다면 왼쪽방향으로 한칸전진. 왼쪽에 가보지 않은 칸이 없다면 왼쪽방향으로 회전. 1단계로 회귀
- 만약 네방향 모두 가본 칸이거나 바다로 되어있는 경우 방향은 유지한채 뒤로 한칸 가고 1단계로 회귀. 이 때 뒤쪽방향이 구현
- 바다인경우 종료

## 럭키 스트레이트 (LuckyStraight)
> 캐릭터는 특정 조건에서 필살기를 사용할 수 있습니다. 특정 조건이란 캐릭터의 점수를 N이라고 할 때 자릿수를 기준으로 점수 N을 반으로 나누어 왼쪽 부분의 자릿수의 합과 오른쪽 부분의 자릿수의 합을 더한 값이 동일한 경우
> 현재 N이 주어지면 럭키 스트레이트를 사용할 수 있는 상태인지 아닌지 구하시오

## 문자열 재정렬(SortedString)
> 알파벳 대문자와 숫자로만 구성된 문자열이 입력으로 주어집니다. 이 때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 모든 숫자를 더한 값을 이어서 출력하시오

## 문자열 압축(StringCompression)
> [문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/60057)
- 문자열은 제일 앞부터 정해진 길이 만큼 잘라야하는것을 잊지 말고, 문자열을 압축하지 못하는 경우는 문자열 전체 길이를 리턴하는 것을 잊지 말것

## 자물쇠와 열쇠(LockerKey)
> [문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/60059)